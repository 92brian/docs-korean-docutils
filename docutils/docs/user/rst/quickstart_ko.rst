=========================
ReStructuredText 입문
=========================

:저자: 리차드 존스(Richard Jones)
:버전: $Revision$
:저작권: 이 문서는 퍼블릭 도메인에 속해있다.

.. Contents::

아래에 있는 텍스트는 "(quickref__)" 같은 링크를 포함하고 있다. 이 링크는 
`빠른 reStructuredText`_ 사용자 레퍼런스에 연결된 상대 링크다. 링크가 작동하지 않는다면
`master quick reference`_ 문서를 참고하기 바란다.

__
.. _빠른 reStructuredText: quickref_ko.html
.. _master quick reference:
   http://docutils.sourceforge.net/docs/user/rst/quickref.html

.. Note:: 이 문서는 reStructuredText에 대한 비공식적인 입문서로 아래에 있는
   `더 알아보기`_ 섹션에 공식적인 레퍼런스를 포함한 더 많은 자료가 링크되어 있다.


Structure
----------

일단, "구조화된 텍스트"는 다소 부정확한 단어라고 말하고 싶다.
오히려 일관된 패턴을 사용하는 "이완된 텍스트"에 가깝다.
이 패턴들은 웹 브라우저로 읽을 수 있는 "매우 구조화된 텍스트"를 만드는 HTML converter에 의해 해석된다.

가장 기본적인 패턴은 **단락** (quickref__) 이다.
단락은 공백 행(한 줄이면 충분하다)으로 분리된 한 덩어리의 텍스트이다.
단락들은 모두 똑같이 들여쓰여져야 한다 -- 즉, 왼쪽 가장자리가 정렬해야 한다.
들여쓰기로 시작된 단락은 들여쓰여진 상태의 인용 단락이 될 것이다::

  이것은 한 단락이다. 좀 짧다.

    이 단락은 일반적으로 다른 문서를 인용하는데 사용되는 들여쓰여진 텍스트 블럭이 될 것이다.

  이것은 또 다른 단락이다.

결과:

  이것은 한 단락이다. 좀 짧다.

    이 단락은 일반적으로 다른 문서를 인용하는데 사용되는 들여쓰여진 텍스트 블럭이 될 것이다.

  이것은 또 다른 단락이다.

__ quickref_ko.html#paragraphs


Text styles
--------------

(quickref__)

__ quickref_ko.html#inline-markup

단락이나 본문 내에서 텍스트를 추가적으로 **두껍게** 하거나 *이탈릭체*\ 로 표시하기 위해
"``**bold**``"와 "``*italics*``"를 사용할 수 있다.
이 방식을 "인라인 마크업"이라고 한다.

만약 당신이 텍스트를 고정폭 리터럴로 표시하고 싶으면 "````백 쿼트를 두 번````" 사용하라.
백 쿼트가 두 번 사용 된 내부에서는 더 이상의 조작이 이루어 지지 않는다.
따라서 "``*``" 같은 것들은 남게 된다.

문서에서 특수 문자를 사용해도 괜찮다. reStructuredText는 상당히 똑똑하다.
예를 들어, 별표도 이 방정식: 5*6=30에서 사용되는 것처럼 제대로 표기된다.
만약 당신이 \*별표로 둘러쌓인 텍스트*가 이탤릭체로 표기되기를 원하지 **않는다면**
당신은 별표를 특수하지 않도록 표시해줘야 한다.
"``\*``" (quickref__) 이렇게 별표 바로 전에 백슬래쉬를 쓰거나
백 쿼트 두 번(인라인 리터럴)으로 양쪽을 닫으면 된다. 이런 식으로::

    ``*``

__ quickref_ko.html#escaping

.. Tip:: 인라인 마크업은 (괄호) 형식으로 생각하고 사용하라: 마크업 될 텍스트 앞과 뒤에 바로 써라.
         공백 문자로 둘러 쌓이거나 단어의 중간에 있는 인라인 마크업은 인식되지 않는다.
         더 자세한 정보는 `markup spec`__ 에서 확인하라.

__ ../../ref/rst/restructuredtext_ko.html#inline-markup


Lists
------

항목을 나열하는 방식은 크게 3가지이다: **enumerated**,
**bulleted**, **definitions**.
모든 리스트는, 단락이든 무엇이든 왼쪽부분이 리스트 항목 텍스트의
첫 줄에 맞춰져 있다면 원하는 만큼 많은 단락과 하위 리스트 등을 가질 수 있다.


리스트는 반드시 새로운 단락으로 시작해야 한다.
즉, 리스트는 공백 행의 다음에 와야 한다.

**enumerated** 리스트 (숫자, 문자 또는 로마 숫자; quickref__)
  __ quickref_ko.html#enumerated-lists

  숫자나 문자 다음  "."을 쓰거나 "( )" 괄호로 둘러싸서 라인을 시작한다.
  --당신이 쓰기 편한 어떤 것이라도 상관 없다.
  아래의 모든 형식이 인식된다::

    1. 숫자

    A. 대문자
       그리고 두 문단 이상으로 이루어진

       여러 줄로 쓸 수도 있다!

    a. 소문자

       3. 다른 숫자로 시작하는 하위 리스트
       4. 숫자가 올바른 순서로 되어 있는지 확인하라!

    I. 로마 대문자 숫자

    i. 로마 소문자 숫자

    (1) 다시 숫자 사용

    1) 다시 숫자 사용

  결과(주석: 다른 enumerated 리스트 스타일은 모든 웹 브라우저에 의해 항상 지원되지 않는다.
  그래서 여기서 전체 결과를 보지 못할 수도 있다):

  1. 숫자

    A. 대문자
       그리고 두 문단 이상으로 이루어진

       여러 줄로 쓸 수도 있다!

    a. 소문자

       3. 다른 숫자로 시작하는 하위 리스트
       4. 숫자가 올바른 순서로 되어 있는지 확인하라!

    I. 로마 대문자 숫자

    i. 로마 소문자 숫자

    (1) 다시 숫자 사용

    1) 다시 숫자 사용

**bulleted** 리스트 (quickref__)
  __ quickref_ko.html#bullet-lists

  enumerated 리스트 처럼, "-", "+" 또는 "*"같은 글머리 기호로 시작한다::

    * "*"를 사용하는 주요 항목

      - "-"를 사용하는 하위 리스트

        + 또 다른 하위 리스트

      - 다른 아이템

  결과:

  * "*"를 사용하는 주요 항목

    - "-"를 사용하는 하위 리스트

      + 또 다른 하위 리스트

    - 다른 아이템

**definition** 리스트 (quickref__)
  __ quickref_ko.html#definition-lists

  다른 두 리스트와 다르게, definition 리스트는 용어와 용어의 설명부분으로 구성되어 있다.
  definition 리스트의 형식은 아래와 같다::

    용어
      Definition 리스트 용어와 정의를 결합시킨다.

    *방식*
      용어는 한 줄의 구문이고, 정의는 용어와 관련이 있는 한 줄 또는 그 이상의 들여쓰여진 단락이나 본문 요소이다.
      용어와 정의 사이에 공백 행은 허용되지 않는다.

  결과:

  용어
      Definition lists 용어와 정의를 결합시킨다.

    *방식*
      용어는 한 줄의 구문이고, 정의는 용어와 관련이 있는 한 줄 또는 그 이상의 들여쓰여진 단락이나 본문 요소이다.
      용어와 정의 사이에 공백 행은 허용되지 않는다.


Preformatting (code samples)
----------------------------
(quickref__)

__ quickref_ko.html#literal-blocks

사전 포맷된 덩어리를 포함시키기 위해서 텍스트를 조작할 필요가 전혀 없다.
전 문단을 "``::``"로 끝내라. 사전 포맷팅된 블럭은 전 문단의 들여쓰기 수준으로
돌아갈 때 끝나게 된다::

  예시::

      공백, 개행, 공백 행, 그리고 모든 종류의 마크업은 리터럴 블럭 안에서 보존된다.
    여기를 보면 들여쓰기 레벨을 떨어뜨렸다.(하지만 충분하지 않다.)

  예시 없음

결과:

  예시::

      공백, 개행, 공백 행, 그리고 모든 종류의 마크업은 리터럴 블럭 안에서 보존된다.
    여기를 보면 들여쓰기 레벨을 떨어뜨렸다.(하지만 충분하지 않다.)

  예시 없음


만약 단락이 "``::``"로만 구성되어 있으면 이 단락은 결과물에서 표시되지 않는다::

  ::

      이것은 사전 포매팅 된 텍스트이다.
      그리고 마지막 "::" 문단은 제거된다.

결과:

::

    이것은 사전 포매팅 된 텍스트이다.
    그리고 마지막 "::" 문단은 제거된다.


Sections
--------

(quickref__)

__ quickref_ko.html#section-structure

긴 문서를 섹션으로 나누기 위해서는 **섹션 헤더**\ 를 써야 한다.
이 것은 하단 줄 또는 하단 줄과 상단 줄 꾸며진 한 줄짜리 텍스트이며
대쉬 "``-----``", 등호 "``======``", 틸드 "``~~~~~~``" 또는 글자와 숫자가 아닌
다른 문자 ``= - ` : ' " ~ ^ _ * + # < >`` 중 어떤 편한 것을 이용해도 상관 없다.
하단 줄로만 장식된 것은 같은 문자를 사용해 하단 줄과 상단 줄로 장식된 것과 구별된다.
하단 줄/상단 줄은 최소한 타이틀 텍스트의 길이는 넘어야 한다.
같은 스타일로 장식된 모든 섹션들은 같은 레벨로 취급되기 때문에 일관성이 있어야 한다::


  Chapter 1 Title
  ================

  Section 1.1 Title
  -----------------

  Subsection 1.1.1 Title
  ~~~~~~~~~~~~~~~~~~~~~~

  Section 1.2 Title
  -----------------

  Chapter 2 Title
  ===============

단순 pseudo-XML로 일러스트 됐을 때 아래의 결과를 얻게 된다::

    <section>
        <title>
            Chapter 1 Title
        <section>
            <title>
                Section 1.1 Title
            <section>
                <title>
                    Subsection 1.1.1 Title
        <section>
            <title>
                Section 1.2 Title
    <section>
        <title>
            Chapter 2 Title

(Pseudo-XML는 내포화를 위해서 들여쓰기를 사용하며 end-tag가 없다.
다른 예시처럼 실제로 처리된 결과를 보여주는 것은 불가능하다.
왜냐하면 블럭 인용문 내에서 섹션은 존재할 수 없다.
구체적인 예시를 보려면 이 문서 소스 텍스트와 처리된 결과의 섹션 구조를 비교해
보아라.)

섹션 헤더는 이름을 이용해서 링크 타겟으로 사용될 수 있다.
Lists_ 제목에 링크하기 위해서 "``Lists_``"\ 라고 쓰면 된다.
만약 제목 안에 공간이 있다면 `Text Styles`_ 이름을 "```Text Styles`_``"로 표시해야 한다.


Document Title / Subtitle
`````````````````````````

전체 문서의 제목은 섹션 제목과 구별되며 조금 다르게 포매팅된다.
(예를들면 기본 HTML writer는 문서 제목을 가운데 정렬시켜 보여준다.)

reStructuredText에서 문서 제목을 나타내기 위해서 문서의 시작 부분에서
고유한 장식 스타일을 사용해야 한다. 부제목을 나타내기 위해서도 문서 제목 바로 다음에
다른 고유한 장식 스타일을 사용해야 한다::

    ================
     Document Title
    ================
    ----------
     Subtitle
    ----------

    Section Title
    =============

    ...

"문서 제목"과 "섹션 제목"은 동일한 기호를 사용하지만 관련이 없는 구별되는 스타일이다.
상단 줄과 하단 줄로 꾸며진 텍스트는 미학적인 부분을 고려해 가운데 정렬시킬 수도 있다.


Images
------

(quickref__)

__ quickref_ko.html#directives

문서에 이미지를 삽입하고 싶으면, ``image`` 명령어__ 를 사용하라::

  .. image:: images/biohazard.png

결과:

.. image:: images/biohazard.png

``images/biohazard.png`` 부분은 문서에 나타타나야 하는 이미지의 파일 이름을 가리킨다.
이미지의 사이즈나 포맷 등에 재한은 없다.
만약 이미지에 추가적인 정보를 입력하고 싶으면 이렇게 입력하면 된다::

  .. image:: images/biohazard.png
     :height: 100
     :width: 200
     :scale: 50
     :alt: alternate text

`image directive documentation`__ 에서 더 많은 정보를 확인하라.

__ ../../ref/rst/directives_ko.html
__ ../../ref/rst/directives_ko.html#images


더 알아보기
--------------

이 문서가 reStructuredText의 가장 기본적인 기능을 소개하고 있지만
아직 살펴봐야 할 내용이 더 많이 남아있다. 다음 단계로는 `빠른 reStructuredText`_  유저
레퍼런스가 있다. 아주 상세한 정보를 원한다면, `reStructuredText 마크업 설명서`_\ 을
살펴보아라. [#]_

Docutils 또는 reStructuredText에 질문이 있거나 도움이 필요한 사용자는
Docutils-users_ 메일링 리스트로 메세지를 보내주기 바란다.

.. [#] 만약 상대 링크가 작동하지 않으면, 마스터문서를 확인해보기 바란다:
   http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html.

.. _reStructuredText 마크업 설명서:
   ../../ref/rst/restructuredtext_ko.html
.. _Docutils-users: ../mailing-lists.html#docutils-users
.. _Docutils project web site: http://docutils.sourceforge.net/
